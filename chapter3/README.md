# 📍 3장 함수

## 📝 목차

- [작게 만들어라](#작게-만들어라)
  - [블록과 들여쓰기](#블록과-들여쓰기)
- [한가지만 해라](#한가지만-해라)
- [함수 당 추상화 수준은 하나로](#함수-당-추상화-수준은-하나로)
  - [위에서 아래로 코드 읽기: 내려가기 규칙](#위에서-아래로-코드-읽기:-내려가기-규칙)
- [Switch 문](#Switch 문)
- [서술적인 이름을 사용하라](#서술적인-이름을-사용하라)
- [함수 인수](#함수-인수)
  - [많이 쓰는 단항 형식](많이-쓰는-단항-형식)
  - [플래그 인수](#플래그-인수)
  - [이항 함수](#이항-함수)
  - [삼항 함수](#삼항-함수)
  - [인수 객체](#인수-객체)
  - [인수 목록](#인수-목록)
  - [동사와 키워드](#동사와-키워드)
- [부수 효과를 일으키지 마라](#부수-효과를-일으키지-마라)
  - [출력 인수](#출력-인수)
- [명령과 조회를 분리하라](#명령과-조회를-분리하라)
- [오류 코드보다 예외를 사용하라](#오류-코드보다-예외를-사용하라)
  - [Try/Catch 블록 뽑아내기](Try/Catch-블록-뽑아내기)
- [반복하지 마라](#반복하지-마라)
- [구조적 프로그래밍](#구조적-프로그래밍)
- [함수를 어떻게 짜죠?](#함수를-어떻게-짜죠?)
- [느낀점](#느낀점)



</br>



------



</br>



- ### 작게 만들어라

  > 함수를 만드는 첫째 규칙은 '작게', 두번째 규칙은 '더 작게'이다.

  

  </br>

  

  - ##### 블록과 들여쓰기

    > if문 / else문 / while문 등에 들어가는 블록은 한 줄이여아 한다.
    >
    > 중첩 구조가 생길만큼 함수가 커져서는 안된다. 



</br>



----

 

</br>

- ### 한가지만 해라

  ###### 함수는 한 가지를 해야한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야한다.

  > 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이기에 함수는 한 가지의 역할만을 수행해야한다.

</br>



----



</br>

- ### 함수 당 추상화 수준은 하나로

  > 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

  

  </br> 

  

  - ##### 위에서 아래로 코드 읽기: 내려가기 규칙

    > 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 
    >
    > 핵심은 짧으면서도 '한 가지'만 하는 함수다.



</br>



-----



</br>



- ### Switch 문

  > 상속 관계로 숨긴 후에는 절대로 다른 코드에 노출하지 않게 만들어 놓는다. 



</br>



-----



</br>

- ### 서술적인 이름을 사용하라

  ###### 좋은 이름이 주는 가치는 아무리 강조해도 지나치지 않다. 

  ###### 길고 서술적이 이름 > 길고 서술적인 주석

  > 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이미 절반은 성공
  >
  > 함수가 작고 단순할수록 서술적인 이름을 고리기도 쉬워진다. 

  



</br>



----



</br>



- ###  함수 인수

  - ##### 많이 쓰는 단항 형식

    > 1. 인수에 질문을 던지는 경우 사용
    > 2. 인수를 뭔가로 변환해 결과를 반환하는 경우 사용
    > 3. 이벤트를 사용하는 경우

    ```java
    boolean fileExists("MyFile") // 첫 번쨰 경우
    InputStream fileOpen("MyFile") // 두 번째 경우
    passwordAttemptFailedNtimes(int attempts) // 세 번째 경우
    ```

  

  </br>

  

  - ##### 플래그 인수

    > 플래그 인수를 사용하는 것은 함수가 여러가지 일을 처리하는 것과 같음

    

    </br>

    

  - ##### 이항 함수

    > 인수가 1개인 함수보다 이해하기 어렵다. 그러므로 가능하면 단항 함수로 바꾸도록 애써야 한다.

    

  </br>

  

  - ##### 삼항 함수

    > 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 그래서 삼항 함수를 만들 때는 신중하게 고려해야한다.

  

  ​	<br>

  

  - ##### 인수 객체

    > 인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어 본다.

    ```java
    Circle makeCircle(double x, double y, double radius);
    Circle makeCircle(Point center, double radius); // 클래스변수로 선언
    ```

  

  </br>

  

  - ##### 인수 목록

    > 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다.

    ```java
    String.format("%s worked %.2f hours", name, hours);
    ```

  

  </br>

  

  - ##### 동사와 키워드

    > 단항 함수는 함수와 인수가 동사 / 명사 쌍을 이뤄야 한다.

    ```java
    writeField(name)
    ```

    

    > 함수 이름에 키워드를 추가하면 인수 순서를 기억할 필요가 없다. 

    ```java
    assertExpectedEqualsActual(expected, actual)
    ```



</br>



-----



</br>



- ### 부수 효과를 일으키지 마라

  > 부수 효과로 특정 기능이 숨겨진 경우에는 더더욱 혼란이 커진다. 

  

  </br>

  

  - ##### 출력 인수

    > 일반적으로 우리는 인수를 함수 입력으로 해석하기에, 출력 인수는 피해야 한다.



</br>



-----



</br>

- ### 명령과 조회를 분리하라

  > 함수는 뭔가를 수행하거나 뭔가에 답을 하거나 둘 중 하나의 기능만을 수행해야 한다

  - ##### 리팩터링 전 코드

    > username이 unclebob으로 설정되어있는지, username을 unclebob으로 설정하는 것인지 모호함.

    ```java
    if(set("username", "unclebob"))....
    ```

    

  - ##### 리펙터링 후 코드

    > 명령과 조회를 분리해 혼란을 없앰

    ```java
    if(attributeExists("username")){
    	setAttribute("username", "unclebob");
    }
    ```

    



</br>



----



</br>



- ### 오류 코드보다 예외를 사용하라

  > 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.
  >
  > 재컴파일 / 재배치 없이도 새 예외 클래스를 추가할 수 있다.

  ```java
  try{
  	deletePage(page);
  } catch(Exception e){
  	logger.log(e.getMessage());
  }
  ```
  

  </br>

  

  - ##### Try/Catch 블록 뽑아내기

    > try/catch문은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞기에 별도의 함수로 뽑아내는 편이 좋다.

    ```java
    public void delete(Page page){
    	try{
    		deletePage(page);
    	}	catch(Exception e) {
    		logError(e);
    	}
    }
    ```

    

</br>



----



</br>



- ### 반복하지 마라

  > 중복을 없애면 가독성이 크게 높아진다.



</br>



---



</br>



- ### 구조적 프로그래밍

  > 모든 함수와 함수 내 모든 블록에 입구과 출구가 하나마나 존재해야한다.
  >
  > 하지만 함수가 작다면 위 규칙은 이익을 제공해주기 않기에, return break, continue 등을 여러 차례 사용해도 괜찮다.



</br>



-----



</br>



- ### 함수를 어떻게 짜죠?

  1. 생각을 기록
  2. 코드 다듬기
  3. 함수 생성
  4. 이름 변환
  5. 중복 제거



</br>



-----



</br>



- ### 느낀점

  > 함수를 만들면서, 위에서 아래로 글을 읽듯이 작성해본 적이 없다. 나는 주로 c++을 다룬다. 그리고 심지어 코드를 짤 때 객체 지향으로 작성하지 않는다. 그러다보니 항상 main에서 호출되어야 하는 함수가 있을 경우 main 함수 위에 다른 함수를 작성해놓고 호출했고, 이런 코드가 썩 좋지 않은 코드라는 것을 깨달았다. 이제부터 객체 지향과 친해져봐야겠다. 그리고 알고리즘을 작성할 때 전역변수가 많으면 좋지 않다는 이야기를 들어 매개 변수를 많이 사용하였었고, 이 또한 코딩하는데에 딱히 도움이 되지 않는 것도 이 책을 통해 알게되었다. 하지만 여기에서 의구심이 들었는데, 알고리즘 문제를 풀 때 전역변수를 최대한 작성하지 않으면서 매개변수도 최소한으로 쓸 수 있는 경우가 있을까? 라는 것이였다. 이에 대한 해답은 아직 잘 모르겠지만, 차차 공부해가면서 알아갈 생각을 하니 기분이 또 새롭다. 

  

