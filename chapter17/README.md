## 📍  17장 냄새와 휴리스틱

- ### 주석

  - #### C1: 부적절한 정보

    > 변경 이력은 장황한 날짜와 따분한 내용으로 소스코드만 번잡하게 만든다.

  - #### C2: 쓸모없는 주석

    > 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더이상 쓸모가 없다. 쓸모 없어진 주석은 재빨리 삭제하는 편이 좋다.

  - #### C3: 중복된 주석

    > 코드만이 충분한데 구구절절 설명하는 주석이 중복된 주석이다.

  - #### C4: 성의 없는 주석

    > 작성할 가치가 있는 주석은 잘 작성할 가치도 있다. 주석을 달 참이라면 시간을 들여 최대한 멋지게 작성한다.

  - #### C5: 주석 처리된 코드

    > 주석 처리 된 코드는 그 자리에 남아 매일매일 낡아간다. 주석으로 처리된 코드를 발견하면 즉각 지워버려라.



</br>



-----



</br>

- ### 환경

  - #### E1: 여러 단계로 빌드해야 한다

    > 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다. 

  - #### E2: 여러 단계로 테스트해야 한다.

    > 아무리 열악한 환경이라도 셀에서 명령 하나로 가능해야 한다.



<br>



----



</br>

- ### 함수

  - #### F1: 너무 많은 인수

    > 함수에서 인수 개수는 작을수록 좋다. 넷 이상은 그 가치가 아주 의심스러우므로 최대한 피한다.

  - #### F2: 출력 인수

    > 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

  - #### F3: 플래그 인수

    > Boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다. 플래그 인수는 혼란을 초래하므로 피해야 마땅하다.



</br>



----



</br>

- ### 일반

  - #### G1: 한 소스 파일에 여러 언어를 사용한다.

    > 이상적으로는 소스 파일 하나에 언어 하나만 사요앟는 방식이 가장 좋다.

  - #### G2: 당연한 동작을 구현하지 않는다.

    > 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. 

  - #### G3: 경계를 올바르게 처리하지 않는다. 

    > 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트 하는 테스트 케이스를 작성하라. 

  - #### G4: 안전 절차 무시

    > 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다. 

  - #### G5: 중복

    > 코드에서 중복을 발견할 때 마다 추상화할 기회로 간주하라. 추상화로 중복을 정리하면 설계언어의 어휘가 늘어난다. 

  - #### G6: 추상화 수준이 올바르지 못하다.

    > 모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다. 

  - #### G7: 기초 클래스가 파생 클래스에 의존한다.

    > 개념을 기초 클래스와 파생 클래스로 나누는 가장 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서다. 일반적으로 기초 클래스는 파상 클래스를 아예 몰라야 마땅하다.

  - #### G8: 과도한 정보

    > 우수한 소프트웨어 개발자는 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다. 클래스가 제공하는 메서드 수는 작을수록 좋다. 

  - #### G9: 죽은 코드

    > 죽은 코드란 실행되지 않는 코드를 가리킨다. 죽은 코드는 설계가 변해도 제대로 수정되지 않기 때문이다. 컴파일은 되지만 새로운 규칙이나 표기법을 따르지 않는다. 

  - #### G10: 수직 분리

    > 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다.

  - #### G11: 일관성 부족

    > 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다. 

  - #### G12: 잡동사니

    > 비어 있는 기본 생성자는 쓸데없이 코드만 복잡하게 만든다. 소스 파일은 언제나 깔끔하게 정리하라! 잡동사니를 없애라!

  - #### G13: 인위적 결합

    > 일반적으로 인위적인 결합은 직접적인 상호작용이 없는 두 모듈 사이에서 일어난다. 뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버린 결과다.
    >
    > 함수 , 상수, 변수를 선언할 때는 시간을 들여 올바른 위치를 고민한다. 

  - #### G14: 기능 욕심

    > 기능 욕심은 한 클래스의 속사정을 다른 클래스에 노출하므로, 별다른 문제가 없다면 제거하는 편이 좋다. 

  - #### G15: 선택자 인수

    > 일반적으로 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.

  - #### G16: 모호한 의도

    > 코드를 짤 때는 의도를 최대한 분명히 밝힌다. 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다. 

  - #### G17: 잘못 치운 책임

    > 소프트웨어 개발자가 내리는 가장 주요한 결정 중 하나가 코드를 배치하는 위치다. 

  - #### G18: 부적절한 static 함수

    > 일반적으로 static 함수보다 인스턴스 함수가 더 좋다. 조금이라도 의심스럽다면 인스턴스 함수로 정의한다. 

  - #### G19: 서술적 변수

    > 서술적인 변수 이름은 많이 써도 괜찮다. 일반적으로는 많을수록 더 좋다.

  - #### G20: 이름과 기능이 일치하는 함수

    > 이름많으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면 더 좋은 일므으로 바꾸거나 아니면 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다. 

  - #### G21: 알고리즘을 이해하라

    > 대다수 괴상한 코드는 사람들이 알고리즘을 충분히 이해하지 않은 채 코드를 구현한 탓이다. 

  - #### G22: 논리적 의존성은 물리적으로 드러내라

    > 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다. 

  - #### G23: If/Else 혹은 Switch/Case문보다 다형성을 사용하라

    > 당장 손쉬운 선택이고, 유형보다 함수가 더 쉽게 변하는 경우는 극히 드물기에 다형성 객체를 생성해 switch문을 대신한다. 

  - #### G24: 표준 표기법을 따르라

    > 팀은 업게 표준에 기반한 구현 표준을 따라야 한다.

  - #### G25: 매직 숫자는 명명된 상수로 교체하라

    > 일반적으로 코드에서 숫자를 사용하지 말라는 규칙이다.

  - #### G26: 정확하라

    > 코드에서 무너가를 결정할 때는 정확히 결정한다 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다. 

  - #### G27: 관례보다 구조를 사용하라

    > 설계 결정을 강제할 때는 규칙보다 관례를 사용한다.

  - #### G28: 논리를 캡슐화하라

    > 조건의 의도를 분명히 밝히는 함수로 표현하라.

  - #### G29: 부정 조건은 피하라

    > 가능하면 긍정 조건으로 표현한다.

  - #### G30: 함수는 한 가지만 해야한다. 

    > 한 가지만 수행하는 좀 더 작은 함수 여럿으로 나눠야 마땅하다.

  - #### G31: 숨겨진 시간적인 결합

    > 함수를 짤 때 함수 인수를 적절히 배치해 함수가 호풀되는 순서를 명백히 드러낸다. 

  - ####  G32:  일관성을 유지하라.

    > 코드 구조를 잡을 때는 이유를 고민하라. 그리고 그 이유를 코드 구조로 명백히 표현하라. 

  - #### G33: 경계 조건을 캡슐화하라

    > 경계 조건은 한 곳에서 별도로 처리한다. 

  - #### G34: 함수는 추상화 수준을 한 단계만 내려가야 한다.

    > 함수 내 모든 문장은 추상화 수준이 동일해아 한다. 그리고 그 추상화 수준은 함수 일므이 의미하는 작업보다 한 단계만 낮아야 한다. 

  - #### G35: 설정 정보는 최상위 단계에 둬라

    > 추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. 

  - #### G36: 추이적 탐색을 피하라

    > 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다. 내가 사용하는 모듈이 내게 필요한 서비스를 모두 제공해야 한다. 원하는 메서드를 찾느라 객체 그래프를 따라 시스템을 탐색할 필요가 없어야 한다. 



<br>



------



</br>



- ### 자바

  - #### J1: 긴 import 목록을 피하고 와일드카드를 사용하라

    > 패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라

  - #### J2: 상수는 상속하지 않는다.

    > 상수를 상속계층 맨 위에 숨겨놓는 대신 static import를 사용하라

  - #### J3: 상수 대 Enum

    > enum 문법은 메서드와 필드도 사용할 수 있다. int보다 훨씬 더 유연하고 서술적인 강력한 도구다. 



</br>



-----



</br>



- ### 이름

  - #### N1: 서술적인 일므을 사용하라

    > 이름은 성급하게 정하지 않는다. 서술적인 이름을 신중하게 고른다. 그러므로 시간을 들여 현명한 이름을 선택하고 유효한 상태로 유지한다. 

  - #### N2: 적절한 추상화 수준에서 이름을 선택하라

    > 구현을 드러내는 이름은 피하라. 

  - #### N3: 가능하다면 표준 명명법을 사용하라

    > 기존 명명법을 사용하는 이름은 이해하기가 더 쉽다. 간단히 말해, 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할 수록 독자가 코드를 이해하기 더 쉬워진다. 

  - #### N4: 명확한 이름

    > 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다. 

  - #### N5: 긴 범위는 긴 이름을 사용하라

    > 이름 길이는 범위 길이에 비례해야 한다. 그러므로 이름 범위가 갈수록 이름을 정확하고 길게 짓는다. 

  - #### N6: 인코딩을 피하라

    > 이름에 유형 정보나 버무이 정보를 넣어서는 안 된다. 헝가리안 표기법의 오염에서 이름을 보호하라.

  - #### N7: 이름으로 부수 효과를 설명하라

    > 함수, 변수, 클래스가 하는 일을 모두 기수하는 이름을 사용한다. 



</br>



----



</br>



- ### 테스트

  - #### T1: 불충분한 테스트

    > 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다. 

  - #### T2: 커버리지 도구를 사용하라!

    > 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다. 

  - #### T3: 사소한 테스트를 건너뛰지 마라

    >  사소한 테스트는 짜기 쉽다. 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다. 

  - #### T4: 무시한 테스트는 모호함을 뜻한다.

    > 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @ignore를 붙혀 표현한다. 

  - #### T5: 경계 조건을 테스트하라

    > 경계 조건은 각별히 산경 써서 테스트한다. 알고리즘의 중앙 조건은 올바로 짜놓고 경계 조건에서 실수하는 경우가 흔하다. 

  - #### T6: 버그 주변은 철저히 테스트하라

    > 버그는 서로 모이는 경향이 있다. 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다. 

  - #### T7: 실패 패턴을 살펴라

    > 합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다. 

  - #### T8: 테스트 커버리지 패턴을 살펴라

    > 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다. 

  - #### T9: 테스트는 빨라야 한다.

    > 일정이 촉박하면 느린 테스트 케이스를 제일 먼저 건너뛴다.



</br>

 

----



</br>



- ### 느낀 점

  > 이 챕터는 지금까지 읽었던 챕터 + 추가적인 리팩터링 방법을 나타낸 챕터인 것 같다. 이 챕터를 읽으면서 지금까지 읽었던 부분들을 다시 한번 상기시키게 되었고, 사소한 것에서도 집중을 가하는 것이 진정한 코드를 대하는 자세라는 것 또한 알게 되었다. 